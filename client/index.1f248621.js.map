{"version":3,"file":"index.1f248621.js","sources":["../../../node_modules/just-curry-it/index.js","../../../node_modules/content-type/index.js","../../../node_modules/@hyperjump/browser/url-resolve-browser/index.js","../../../node_modules/@hyperjump/browser/fetch.browser.js","../../../node_modules/@hyperjump/browser/common.js","../../../node_modules/@hyperjump/browser/core.js","../../../node_modules/@hyperjump/browser/json/core.js","../../../node_modules/@hyperjump/browser/json/index.js","../../../node_modules/@hyperjump/json-pointer/json-pointer.js","../../../node_modules/@hyperjump/browser/json-reference/core.js","../../../node_modules/@hyperjump/browser/json-reference/index.js","../../../node_modules/@hyperjump/browser/index.js","../../../src/components/Hyperjump-lib.js","../../../src/components/Hyperjump.svelte","../../../src/routes/index.svelte"],"sourcesContent":["module.exports = curry;\n\n/*\n  function add(a, b, c) {\n    return a + b + c;\n  }\n  curry(add)(1)(2)(3); // 6\n  curry(add)(1)(2)(2); // 5\n  curry(add)(2)(4, 3); // 9\n\n  function add(...args) {\n    return args.reduce((sum, n) => sum + n, 0)\n  }\n  var curryAdd4 = curry(add, 4)\n  curryAdd4(1)(2, 3)(4); // 10\n\n  function converter(ratio, input) {\n    return (input*ratio).toFixed(1);\n  }\n  const curriedConverter = curry(converter)\n  const milesToKm = curriedConverter(1.62);\n  milesToKm(35); // 56.7\n  milesToKm(10); // 16.2\n*/\n\nfunction curry(fn, arity) {\n  return function curried() {\n    if (arity == null) {\n      arity = fn.length;\n    }\n    var args = [].slice.call(arguments);\n    if (args.length >= arity) {\n      return fn.apply(this, args);\n    } else {\n      return function() {\n        return curried.apply(this, args.concat([].slice.call(arguments)));\n      };\n    }\n  };\n}\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","/* eslint-disable */\n'use strict';\nmodule.exports = urlResolve;\n\n/*\nThe majority of the module is built by following RFC1808\nurl: https://tools.ietf.org/html/rfc1808\n*/\n\n// adds a slash at end if not present\nfunction _addSlash (url) {\n  return url + (url[url.length-1] === '/' ? '' : '/');\n}\n\n// resolve the ..'s (directory up) and such\nfunction _pathResolve (path) {\n  let pathSplit = path.split('/');\n\n  // happens when path starts with /\n  if (pathSplit[0] === '') {\n    pathSplit = pathSplit.slice(1);\n  }\n\n  // let segmentCount = 0; // number of segments that have been passed\n  let resultArray = [];\n  pathSplit.forEach((current, index) => {\n    // skip occurances of '.'\n    if (current !== '.') {\n      if (current === '..') {\n        resultArray.pop(); // remove previous\n      } else if (current !== '') {\n        resultArray.push(current);\n      }\n    }\n  });\n  return '/' + resultArray.join('/');\n}\n\n// parses a base url string into an object containing host, path and query\nfunction _baseParse (base) {\n  const resultObject = {\n    host: '',\n    path: '',\n    query: '',\n    protocol: ''\n  };\n\n  let path = base;\n  let protocolEndIndex = base.indexOf('//');\n\n  if (protocolEndIndex === -1) {\n    throw new Error('Error, protocol is not specified');\n  }\n\n  resultObject.protocol = path.substring(0, protocolEndIndex);\n\n  protocolEndIndex += 2; // add two to pass double slash\n\n  const pathIndex = base.indexOf('/', protocolEndIndex);\n  const queryIndex = base.indexOf('?');\n  const hashIndex = base.indexOf('#');\n\n  if (hashIndex !== -1) {\n    path = path.substring(0, hashIndex); // remove hash, not needed for base\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex); // remove query, save in return obj\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  if (pathIndex !== -1) {\n    const host = path.substring(0, pathIndex); // separate host & path\n    resultObject.host = host;\n    path = path.substring(pathIndex);\n    resultObject.path = path;\n  } else {\n    resultObject.host = path; // there was no path, therefore path is host\n  }\n\n  return resultObject;\n}\n\nfunction _isAbsolute(relative) {\n  // https://tools.ietf.org/html/rfc3986#section-3.1\n  const scheme = '[a-z][a-z0-9+.-]*'; // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\"  )]\n  const isAbsolutePattern = new RegExp(`^(${scheme}:)?//`, 'i');\n  return isAbsolutePattern.test(relative);\n}\n\n// parses a relative url string into an object containing the href,\n// hash, query and whether it is a net path, absolute path or relative path\nfunction _relativeParse (relative) {\n  const resultObject = {\n    href: relative, // href is always what was passed through\n    hash: '',\n    query: '',\n    netPath: false,\n    absolutePath: false,\n    relativePath: false\n  };\n  // check for protocol\n  // if protocol exists, is net path (absolute URL)\n  if (_isAbsolute(relative)) {\n    resultObject.netPath = true;\n    // return, in this case the relative is the resolved url, no need to parse.\n    return resultObject;\n  }\n\n  // if / is first, this is an absolute path,\n  // I.E. it overwrites the base URL's path\n  if (relative[0] === '/') {\n    resultObject.absolutePath = true;\n    // return resultObject\n  } else {\n    resultObject.relativePath = true;\n  }\n\n  let path = relative;\n  const queryIndex = relative.indexOf('?');\n  const hashIndex = relative.indexOf('#');\n\n  if (hashIndex !== -1) {\n    const hash = path.substring(hashIndex);\n    resultObject.hash = hash;\n    path = path.substring(0, hashIndex);\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex);\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  resultObject.path = path; // whatever is left is path\n  return resultObject;\n}\n\nfunction _shouldAddSlash (url) {\n  const protocolIndex = url.indexOf('//') + 2;\n  const noPath = !(url.includes('/', protocolIndex));\n  const noQuery = !(url.includes('?', protocolIndex));\n  const noHash = !(url.includes('#', protocolIndex));\n  return (noPath && noQuery && noHash);\n}\n\nfunction _shouldAddProtocol (url) {\n  return url.startsWith('//');\n}\n\n/*\n* PRECONDITION: Base is a fully qualified URL. e.g. http://example.com/\n* optional: path, query or hash\n* returns the resolved url\n*/\nfunction urlResolve (base, relative) {\n  base = base.trim();\n  relative = relative.trim();\n\n  // about is always absolute\n  if (relative.startsWith('about:')) {\n    return relative;\n  }\n\n  // if base is empty, assume relative is a net path.\n  if (base === '') {\n    if (_shouldAddSlash(relative)) {\n      return _addSlash(relative);\n    }\n    // add / at end if not present if is only the host\n    return relative;\n  }\n  const baseObj = _baseParse(base);\n  // relative is empty, return base minus hash\n  if (relative === '') {\n    const {host, path, query} = baseObj;\n    // when path and query aren't supplied add slash\n    if ((!path) && (!query)) {\n      return _addSlash(host);\n    }\n    return host + path + query;\n  }\n\n  const relativeObj = _relativeParse(relative);\n\n  if (relativeObj.netPath) { // relative is full qualified URL\n    if (_shouldAddProtocol(relativeObj.href)) {\n      relativeObj.href = baseObj.protocol + relativeObj.href;\n    }\n\n    if (_shouldAddSlash(relativeObj.href)) {\n      return _addSlash(relativeObj.href);\n    }\n\n    return relativeObj.href;\n  } else if (relativeObj.absolutePath) { // relative is an absolute path\n    const {path, query, hash} = relativeObj;\n\n    return baseObj.host + _pathResolve(path) + query + hash;\n  } else if (relativeObj.relativePath) { // relative is a relative path\n    const {path, query, hash} = relativeObj;\n\n    let basePath = baseObj.path;\n    let resultString = baseObj.host;\n\n    let resolvePath;\n\n    if (path.length === 0) {\n      resolvePath = basePath;\n    } else {\n      // remove last segment if no slash at end\n      basePath = basePath.substring(0, basePath.lastIndexOf('/'));\n      resolvePath = _pathResolve(basePath + '/' + path);\n    }\n\n    // if result is just the base host, add /\n    if ((resolvePath === '') && (!query) && (!hash)) {\n      resultString += '/';\n    } else {\n      resultString += resolvePath + query + hash;\n    }\n\n    return resultString;\n  }\n}\n","module.exports = fetch;\n","const uriReference = (url) => url.split(\"#\", 1)[0];\nconst uriFragment = (url) => url.split(\"#\", 2)[1] || \"\";\nconst isObject = (value) => typeof value === \"object\" && !Array.isArray(value) && value !== null;\n\nmodule.exports = { uriReference, uriFragment, isObject };\n","const curry = require(\"just-curry-it\");\nconst contentTypeParser = require(\"content-type\");\nconst resolveUrl = require(\"./url-resolve-browser\");\nconst fetch = require(\"./fetch\");\nconst { uriReference, isObject } = require(\"./common\");\n\n\nconst construct = (url, headers, body) => Object.freeze({ url, headers, body });\nconst extend = (doc, extras) => Object.freeze({ ...doc, ...extras });\n\nconst nil = construct(\"\", {}, undefined);\nconst source = (doc) => doc.body;\nconst value = (doc) => isDocument(doc) ? contentTypeHandler(doc).value(doc) : doc;\n\nconst get = curry(async (url, contextDoc, options = {}) => {\n  let result;\n  const doc = await contextDoc;\n  const resolvedUrl = resolveUrl(doc.url, url);\n\n  if (uriReference(doc.url) === uriReference(resolvedUrl)) {\n    result = extend(doc, { url: resolvedUrl });\n  } else if (doc.embedded && uriReference(resolvedUrl) in doc.embedded) {\n    const headers = { \"content-type\": doc.headers[\"content-type\"] };\n    result = construct(resolvedUrl, headers, doc.embedded[resolvedUrl]);\n  } else {\n    const response = await fetch(resolvedUrl, options);\n    const headers = {};\n    for (const [name, value] of response.headers.entries()) {\n      headers[name] = value;\n    }\n    result = construct(resolvedUrl, headers, await response.text());\n  }\n\n  return await contentTypeHandler(result).get(result, options);\n});\n\nconst step = curry(async (key, doc, options = {}) => isDocument(await doc) ? (\n  contentTypeHandler(await doc).step(key, await doc, options)\n) : (\n  (await doc)[key]\n));\n\nconst entries = async (doc, options = {}) => isDocument(await doc) ? (\n  Promise.all(Object.keys(value(await doc))\n    .map(async (key) => [key, await step(key, await doc, options)]))\n) : (\n  Object.entries(await doc)\n);\n\nconst map = curry(async (fn, doc, options = {}) => {\n  const list = (await entries(doc, options))\n    .map(([key, item]) => fn(item, key));\n\n  return Promise.all(list);\n});\n\nconst filter = curry(async (fn, doc, options = {}) => {\n  return reduce(async (acc, item) => {\n    return (await fn(item)) ? acc.concat([item]) : acc;\n  }, [], doc, options);\n});\n\nconst some = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .some((a) => a);\n});\n\nconst every = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .every((a) => a);\n});\n\nconst reduce = curry(async (fn, acc, doc, options = {}) => {\n  return (await entries(doc, options))\n    .reduce(async (acc, [_key, item]) => fn(await acc, item), acc);\n});\n\nconst pipeline = curry((fns, doc) => {\n  return fns.reduce(async (acc, fn) => fn(await acc), doc);\n});\n\nconst addContentType = (contentType, handler) => contentTypes[contentType] = handler;\n\nconst contentTypes = {};\n\nconst defaultHandler = {\n  get: async (doc) => doc,\n  value: source,\n  step: async (key, doc) => value(doc)[key]\n};\n\nconst contentTypeHandler = (doc) => {\n  if (doc === nil) {\n    return defaultHandler;\n  }\n\n  const contentType = contentTypeParser.parse(doc.headers[\"content-type\"]).type;\n  return contentType in contentTypes ? contentTypes[contentType] : defaultHandler;\n};\n\nconst isDocument = (value) => isObject(value) && \"url\" in value;\n\nmodule.exports = {\n  construct, extend, addContentType,\n  nil, get, source, value, entries, step, map, filter, reduce, some, every, pipeline\n};\n","const Hyperjump = require(\"../core\");\n\n\nconst get = async (doc) => {\n  const json = JSON.parse(Hyperjump.source(doc));\n  return !(\"json\" in doc) ? Hyperjump.extend(doc, { json }) : doc;\n};\nconst value = (doc) => doc.json;\nconst step = async (key, doc) => value(doc)[key];\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/json\", Core);\n\nmodule.exports = Hyperjump;\n","const curry = require(\"just-curry-it\");\n\n\nconst nil = \"\";\n\nconst get = (pointer, value = undefined) => {\n  if (pointer.length > 0 && pointer[0] !== \"/\") {\n    throw Error(\"Invalid JSON Pointer\");\n  }\n\n  const ptr = pointer.split(\"/\").slice(1).map(unescape);\n\n  const fn = (value) => ptr.reduce(([value, pointer], segment) => {\n    return [applySegment(value, segment, pointer), append(segment, pointer)];\n  }, [value, \"\"])[0];\n\n  return value === undefined ? fn : fn(value);\n};\n\nconst append = curry((segment, pointer) => pointer + \"/\" + escape(segment));\n\nconst escape = (segment) => segment.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\nconst unescape = (segment) => segment.toString().replace(/~0/g, \"~\").replace(/~1/g, \"/\");\n\nconst applySegment = (value, segment, pointer = \"\") => {\n  if (value === null || typeof value !== \"object\") {\n    throw Error(`Value at '${pointer}' is a scalar and can't be indexed`);\n  } else if (!(segment in value)) {\n    throw Error(`Value at '${pointer}' does not have index '${segment}'`);\n  }\n\n  return value[segment];\n};\n\nmodule.exports = { nil, get, append };\n","const JsonPointer = require(\"@hyperjump/json-pointer\");\nconst Hyperjump = require(\"../core\");\nconst { uriReference, uriFragment, isObject } = require(\"../common\");\n\n\nconst get = async (doc, options) => {\n  const jrefDoc = !(\"jref\" in doc) ? Hyperjump.extend(doc, parse(doc)) : doc;\n  const docValue = value(jrefDoc);\n  return isHref(docValue) ? await Hyperjump.get(docValue[\"$href\"], jrefDoc, options) : jrefDoc;\n};\n\nconst parse = (doc) => {\n  const embedded = {};\n  const jref = JSON.parse(Hyperjump.source(doc), (key, value) => {\n    if (isEmbedded(value)) {\n      const id = uriReference(value[\"$embedded\"]);\n      delete value[\"$embedded\"];\n      embedded[id] = JSON.stringify(value);\n      return { \"$href\": id };\n    } else {\n      return value;\n    }\n  });\n\n  return { jref, embedded };\n};\n\nconst value = (doc) => JsonPointer.get(pointer(doc), doc.jref);\n\nconst step = (key, doc, options = {}) => {\n  const ptr = JsonPointer.append(key, pointer(doc));\n  const url = \"#\" + encodeURI(ptr).replace(/#/g, \"%23\");\n  return Hyperjump.get(url, doc, options);\n};\n\nconst pointer = (doc) => decodeURIComponent(uriFragment(doc.url));\nconst isHref = (value) => isObject(value) && \"$href\" in value;\nconst isEmbedded = (value) => isObject(value) && \"$embedded\" in value;\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/reference+json\", Core);\n\nmodule.exports = Hyperjump;\n","const Hyperjump = require(\"./core\");\nrequire(\"./json\");\nrequire(\"./json-reference\");\n\n\nmodule.exports = Hyperjump;\n","import JsonPointer from \"@hyperjump/json-pointer\";\nimport resolveUrl from \"@hyperjump/browser/url-resolve-browser\";\n\n\nconst jsonTypeOf = (value) => {\n  if (value === null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  const type = typeof value;\n  return type === \"object\" && \"$href\" in value ? \"href\" : type;\n};\n\nconst uriFragment = (url) => url.split(\"#\", 2)[1] || \"\";\nconst pointer = (url) => decodeURIComponent(uriFragment(url));\nconst stepUrl = (propertyName, url) => {\n  const ptr = JsonPointer.append(propertyName, pointer(url));\n  const fragment = \"#\" + encodeURI(ptr).replace(/#/g, \"%23\");\n  return resolveUrl(url, fragment);\n};\n\nconst newLine = (lines) => lines.push([]);\n\nconst pushToken = (lines, ...tokens) => {\n  lines[lines.length - 1].push(...tokens);\n};\n\nconst times = (n, subject) => {\n  const items = [];\n  for (let i = 0; i < n; i++) {\n    items.push(subject);\n  }\n\n  return items;\n};\n\nexport const generateLines = (url, json, lines = [[]], depth = 0) => {\n  const jsonType = jsonTypeOf(json);\n\n  if (jsonType === \"object\") {\n    pushToken(lines, [\"GROUPING\", \"{\"]);\n    newLine(lines);\n    const entries = Object.entries(json);\n    for (let ndx = 0; ndx < entries.length; ndx++) {\n      const [propertyName, propertyValue] = entries[ndx];\n\n      const propertyUrl = stepUrl(propertyName, url);\n      pushToken(lines, ...times(depth + 1, [\"INDENT\"]), [\"PROPERTY\", propertyName, propertyUrl]);\n      generateLines(propertyUrl, propertyValue, lines, depth + 1);\n      ndx < entries.length - 1 && pushToken(lines, [\"COMMA\"]);\n      newLine(lines);\n    }\n    pushToken(lines, ...times(depth, [\"INDENT\"]), [\"GROUPING\", \"}\"]);\n  } else if (jsonType === \"array\") {\n    pushToken(lines, [\"GROUPING\", \"[\"]);\n    newLine(lines);\n    for (let ndx = 0; ndx < json.length; ndx++) {\n      const propertyUrl = stepUrl(ndx, url);\n      pushToken(lines, ...times(depth + 1, [\"INDENT\"]), [\"ARRAY_INDEX\", ndx, propertyUrl]);\n      generateLines(propertyUrl, json[ndx], lines, depth + 1);\n      ndx < json.length - 1 && pushToken(lines, [\"COMMA\"]);\n      newLine(lines);\n    }\n    pushToken(lines, ...times(depth, [\"INDENT\"]), [\"GROUPING\", \"]\"]);\n  } else if (jsonType === \"string\") {\n    pushToken(lines, [\"STRING\", json]);\n  } else if (jsonType === \"number\") {\n    pushToken(lines, [\"NUMBER\", json]);\n  } else if (jsonType === \"boolean\") {\n    pushToken(lines, [\"ATOM\", json ? \"true\": \"false\"]);\n  } else if (jsonType === \"null\") {\n    pushToken(lines, [\"ATOM\", \"null\"]);\n  } else if (jsonType === \"href\") {\n    pushToken(lines, [\"HREF\", resolveUrl(url, json[\"$href\"])]);\n  }\n\n  return lines;\n};\n","<script>\n  import Hyperjump from \"@hyperjump/browser\";\n  import { generateLines } from \"./Hyperjump-lib\";\n  import Fixed from \"./Fixed.svelte\";\n\n\n  export let doc;\n  export let indent;\n  export let theme;\n\n  $: lines = (async function () {\n    const d = await doc;\n    const value = Hyperjump.value(d);\n    return generateLines(d.url, value);\n  }());\n</script>\n\n<div class=\"hyperjump {theme}\">\n  {#await lines}\n    ... Loading ...\n  {:then lines}\n    {#each lines as line}\n      <div class=\"line\">\n        {#each line as token}\n          {#if token[0] === \"GROUPING\"}\n            <span class=\"grouping\">{token[1]}</span>\n          {:else if token[0] === \"PROPERTY\"}\n            &quot;<span class=\"property\"><a href=\"#{token[2]}\">{token[1]}</a></span>&quot;:&nbsp;\n          {:else if token[0] === \"ARRAY_INDEX\"}\n            <Fixed><a href=\"#{token[2]}\" class=\"array-index\">{token[1]}</a></Fixed>\n          {:else if token[0] === \"STRING\"}\n            &quot;<span class=\"string\">{token[1]}</span>&quot;\n          {:else if token[0] === \"NUMBER\"}\n            <span class=\"number\">{token[1]}</span>\n          {:else if token[0] === \"ATOM\"}\n            <span class=\"atom\">{token[1]}</span>\n          {:else if token[0] === \"HREF\"}\n            <a href=\"#{token[1]}\">...</a>\n          {:else if token[0] === \"COMMA\"}\n            ,\n          {:else if token[0] === \"INDENT\"}\n            {@html \"&nbsp;\".repeat(indent)}\n          {/if}\n        {/each}\n      </div>\n    {/each}\n  {:catch error}\n    {error.message}\n  {/await}\n</div>\n\n<style>\n  .hyperjump {\n    display: block;\n    font-family: monospace;\n  }\n\n  a {\n    color: inherit;\n  }\n\n  a:hover {\n    font-weight: bold;\n    filter: brightness(150%);\n  }\n\n  .array-index {\n    right: .125em;\n    filter: brightness(50%);\n  }\n\n  .line {\n    white-space: nowrap;\n  }\n\n  .line:hover {\n    background-color: var(--line-focus-background-color);\n  }\n\n  .line:hover .array-index {\n    filter: brightness(100%);\n  }\n\n  .grouping {\n    color: var(--grouping-color);\n  }\n\n  .property {\n    color: var(--property-color);\n  }\n\n  .string {\n    color: var(--string-color);\n  }\n\n  .number {\n    color: var(--number-color);\n  }\n\n  .atom {\n    color: var(--boolean-color);\n  }\n</style>\n","<script>\n  import { onMount } from \"svelte\"\n  import Hyperjump from \"@hyperjump/browser\";\n  import JRef from \"@hyperjump/browser/json-reference/core\";\n  import HyperjumpCode from \"../components/Hyperjump.svelte\";\n\n\n  Hyperjump.addContentType(\"application/validation+json\", JRef);\n\n  let url = \"\";\n  const theme = \"solarized-dark\";\n\n  onMount(() => {\n    if (window.location.href.slice(window.location.origin.length) === window.location.pathname) {\n      window.location.replace(\"/#\");\n    }\n\n    onHashChange();\n  });\n\n  const onHashChange = () => {\n    url = decodeURI(window.location.hash.substring(1));\n  };\n\n  const go = (event) => {\n    if (event.keyCode === 13) {\n      window.location.hash = encodeURI(event.target.value);\n      url = event.target.value;\n    }\n  }\n\n  $: doc = (async function () {\n    if (url === \"\") {\n      return Hyperjump.nil;\n    }\n\n    const schemelessUrl = location.href.match(/.+?:(.+)/)[1];\n    const scheme = url.split(\":\", 1)[0];\n    window.location.replace(`${scheme}:${schemelessUrl}`);\n\n    const nextDoc = await Hyperjump.get(url, doc || Hyperjump.nil);\n    window.location.replace(window.location.origin + \"/#\" + encodeURI(nextDoc.url));\n\n    return nextDoc;\n  }());\n</script>\n\n<svelte:window on:hashchange={onHashChange} />\n\n<svelte:head>\n\t<title>Hyperjump</title>\n</svelte:head>\n\n<main>\n  <h1>Hyperjump</h1>\n\n  <input class=\"url-bar {theme}\"\n         placeholder=\"https://\"\n         value={url}\n         on:keyup={go}\n         aria-label=\"URL Bar\" />\n  <HyperjumpCode {doc} indent=\"2\" {theme} />\n</main>\n\n<style>\n  .url-bar {\n    width: 100%;\n    box-sizing: border-box;\n    padding: .5em;\n    border: none;\n    margin-bottom: .5em;\n    font-family: monospace;\n  }\n\n  .url-bar:focus {\n    background-color: var(--line-focus-background-color);\n  }\n\n  :global(.hyperjump) {\n    height: 100%;\n    line-height: 1.5em;\n    overflow-y: scroll;\n    padding: .5em;\n    margin-bottom: 1em;\n  }\n</style>\n"],"names":["fn","arity","curried","length","args","slice","call","arguments","apply","this","concat","PARAM_REGEXP","TEXT_REGEXP","TOKEN_REGEXP","QESC_REGEXP","QUOTE_REGEXP","TYPE_REGEXP","qstring","val","str","String","test","TypeError","replace","ContentType","type","parameters","Object","create","obj","string","param","params","keys","sort","i","header","getHeader","headers","getcontenttype","index","indexOf","substr","trim","toLowerCase","key","match","value","lastIndex","exec","base","relative","startsWith","_shouldAddSlash","_addSlash","baseObj","resultObject","host","path","query","protocol","protocolEndIndex","Error","substring","pathIndex","queryIndex","hashIndex","_baseParse","relativeObj","href","hash","netPath","absolutePath","relativePath","RegExp","_isAbsolute","_relativeParse","_pathResolve","resolvePath","basePath","resultString","lastIndexOf","url","pathSplit","split","resultArray","forEach","current","pop","push","join","protocolIndex","noPath","includes","noQuery","noHash","fetch","uriReference","uriFragment","isObject","Array","isArray","require$$0","construct","body","freeze","extend","doc","extras","nil","undefined","source","isDocument","contentTypeHandler","get","curry","async","contextDoc","options","result","resolvedUrl","resolveUrl","embedded","content-type","response","name","entries","text","step","Promise","all","map","list","item","filter","reduce","acc","some","a","every","_key","pipeline","fns","contentTypes","defaultHandler","contentType","contentTypeParser","parse","addContentType","handler","json","JSON","Hyperjump","Core","append","segment","pointer","escape","toString","unescape","applySegment","ptr","jref","isEmbedded","id","stringify","$href","JsonPointer","decodeURIComponent","isHref","jrefDoc","docValue","encodeURI","stepUrl","propertyName","fragment","newLine","lines","pushToken","tokens","times","n","subject","items","generateLines","depth","jsonType","jsonTypeOf","ndx","propertyValue","propertyUrl","error","message","repeat","indent","token","line","theme","d","onHashChange","go","JRef","onMount","window","location","origin","pathname","decodeURI","schemelessUrl","scheme","nextDoc","event","keyCode","target"],"mappings":"mQAAA,MAyBA,SAAeA,EAAIC,GACjB,OAAO,SAASC,IACD,MAATD,IACFA,EAAQD,EAAGG,QAEb,IAAIC,EAAO,GAAGC,MAAMC,KAAKC,WACzB,OAAIH,EAAKD,QAAUF,EACVD,EAAGQ,MAAMC,KAAML,GAEf,WACL,OAAOF,EAAQM,MAAMC,KAAML,EAAKM,OAAO,GAAGL,MAAMC,KAAKC,gBCb7D,IAAII,EAAe,mKACfC,EAAc,wCACdC,EAAe,gCAQfC,EAAc,6BAKdC,EAAe,WASfC,EAAc,6DAyJlB,SAASC,EAASC,GAChB,IAAIC,EAAMC,OAAOF,GAGjB,GAAIL,EAAaQ,KAAKF,GACpB,OAAOA,EAGT,GAAIA,EAAIhB,OAAS,IAAMS,EAAYS,KAAKF,GACtC,MAAM,IAAIG,UAAU,2BAGtB,MAAO,IAAMH,EAAII,QAAQR,EAAc,QAAU,IAOnD,SAASS,EAAaC,GACpBhB,KAAKiB,WAAaC,OAAOC,OAAO,MAChCnB,KAAKgB,KAAOA,gBA5Jd,SAAiBI,GACf,IAAKA,GAAsB,iBAARA,EACjB,MAAM,IAAIP,UAAU,4BAGtB,IAAII,EAAaG,EAAIH,WACjBD,EAAOI,EAAIJ,KAEf,IAAKA,IAAST,EAAYK,KAAKI,GAC7B,MAAM,IAAIH,UAAU,gBAGtB,IAAIQ,EAASL,EAGb,GAAIC,GAAoC,iBAAfA,EAIvB,IAHA,IAAIK,EACAC,EAASL,OAAOM,KAAKP,GAAYQ,OAE5BC,EAAI,EAAGA,EAAIH,EAAO7B,OAAQgC,IAAK,CAGtC,GAFAJ,EAAQC,EAAOG,IAEVtB,EAAaQ,KAAKU,GACrB,MAAM,IAAIT,UAAU,0BAGtBQ,GAAU,KAAOC,EAAQ,IAAMd,EAAQS,EAAWK,IAItD,OAAOD,SAWT,SAAgBA,GACd,IAAKA,EACH,MAAM,IAAIR,UAAU,+BAItB,IAAIc,EAA2B,iBAAXN,EA8DtB,SAAyBD,GACvB,IAAIO,EAEyB,mBAAlBP,EAAIQ,UAEbD,EAASP,EAAIQ,UAAU,gBACS,iBAAhBR,EAAIS,UAEpBF,EAASP,EAAIS,SAAWT,EAAIS,QAAQ,iBAGtC,GAAsB,iBAAXF,EACT,MAAM,IAAId,UAAU,8CAGtB,OAAOc,EA5EHG,CAAeT,GACfA,EAEJ,GAAsB,iBAAXM,EACT,MAAM,IAAId,UAAU,8CAGtB,IAAIkB,EAAQJ,EAAOK,QAAQ,KACvBhB,GAAkB,IAAXe,EACPJ,EAAOM,OAAO,EAAGF,GAAOG,OACxBP,EAAOO,OAEX,IAAK3B,EAAYK,KAAKI,GACpB,MAAM,IAAIH,UAAU,sBAGtB,IAAIO,EAAM,IAAIL,EAAYC,EAAKmB,eAG/B,IAAe,IAAXJ,EAAc,CAChB,IAAIK,EACAC,EACAC,EAIJ,IAFApC,EAAaqC,UAAYR,EAEjBM,EAAQnC,EAAasC,KAAKb,IAAU,CAC1C,GAAIU,EAAMN,QAAUA,EAClB,MAAM,IAAIlB,UAAU,4BAGtBkB,GAASM,EAAM,GAAG3C,OAClB0C,EAAMC,EAAM,GAAGF,cAGE,OAFjBG,EAAQD,EAAM,IAEJ,KAERC,EAAQA,EACLL,OAAO,EAAGK,EAAM5C,OAAS,GACzBoB,QAAQT,EAAa,OAG1Be,EAAIH,WAAWmB,GAAOE,EAGxB,GAAIP,IAAUJ,EAAOjC,OACnB,MAAM,IAAImB,UAAU,4BAIxB,OAAOO,MCNT,SAAqBqB,EAAMC,GAKzB,GAJAD,EAAOA,EAAKP,QACZQ,EAAWA,EAASR,QAGPS,WAAW,UACtB,OAAOD,EAIT,GAAa,KAATD,EACF,OAAIG,EAAgBF,GACXG,EAAUH,GAGZA,EAET,MAAMI,EAtIR,SAAqBL,GACnB,MAAMM,EAAe,CACnBC,KAAM,GACNC,KAAM,GACNC,MAAO,GACPC,SAAU,IAGZ,IAAIF,EAAOR,EACPW,EAAmBX,EAAKT,QAAQ,MAEpC,IAA0B,IAAtBoB,EACF,MAAM,IAAIC,MAAM,oCAGlBN,EAAaI,SAAWF,EAAKK,UAAU,EAAGF,GAE1CA,GAAoB,EAEpB,MAAMG,EAAYd,EAAKT,QAAQ,IAAKoB,GAC9BI,EAAaf,EAAKT,QAAQ,KAC1ByB,EAAYhB,EAAKT,QAAQ,MAEZ,IAAfyB,IACFR,EAAOA,EAAKK,UAAU,EAAGG,IAG3B,IAAoB,IAAhBD,EAAmB,CACrB,MAAMN,EAAQD,EAAKK,UAAUE,GAC7BT,EAAaG,MAAQA,EACrBD,EAAOA,EAAKK,UAAU,EAAGE,GAG3B,IAAmB,IAAfD,EAAkB,CACpB,MAAMP,EAAOC,EAAKK,UAAU,EAAGC,GAC/BR,EAAaC,KAAOA,EACpBC,EAAOA,EAAKK,UAAUC,GACtBR,EAAaE,KAAOA,OAEpBF,EAAaC,KAAOC,EAGtB,OAAOF,EA4FSW,CAAWjB,GAE3B,GAAiB,KAAbC,EAAiB,CACnB,MAAMM,KAACA,EAAIC,KAAEA,EAAIC,MAAEA,GAASJ,EAE5B,OAAMG,GAAWC,EAGVF,EAAOC,EAAOC,EAFZL,EAAUG,GAKrB,MAAMW,EA3FR,SAAyBjB,GACvB,MAAMK,EAAe,CACnBa,KAAMlB,EACNmB,KAAM,GACNX,MAAO,GACPY,SAAS,EACTC,cAAc,EACdC,cAAc,GAIhB,GApBF,SAAqBtB,GAInB,OAD0B,IAAIuB,OAAO,2BAAoB,KAChCrD,KAAK8B,GAgB1BwB,CAAYxB,GAGd,OAFAK,EAAae,SAAU,EAEhBf,EAKW,MAAhBL,EAAS,GACXK,EAAagB,cAAe,EAG5BhB,EAAaiB,cAAe,EAG9B,IAAIf,EAAOP,EACX,MAAMc,EAAad,EAASV,QAAQ,KAC9ByB,EAAYf,EAASV,QAAQ,KAEnC,IAAmB,IAAfyB,EAAkB,CACpB,MAAMI,EAAOZ,EAAKK,UAAUG,GAC5BV,EAAac,KAAOA,EACpBZ,EAAOA,EAAKK,UAAU,EAAGG,GAG3B,IAAoB,IAAhBD,EAAmB,CACrB,MAAMN,EAAQD,EAAKK,UAAUE,GAC7BT,EAAaG,MAAQA,EACrBD,EAAOA,EAAKK,UAAU,EAAGE,GAI3B,OADAT,EAAaE,KAAOA,EACbF,EAgDaoB,CAAezB,GAEnC,GAAIiB,EAAYG,QAKd,OAJuBH,EAAYC,KAvC1BjB,WAAW,QAwClBgB,EAAYC,KAAOd,EAAQK,SAAWQ,EAAYC,MAGhDhB,EAAgBe,EAAYC,MACvBf,EAAUc,EAAYC,MAGxBD,EAAYC,KACd,GAAID,EAAYI,aAAc,CACnC,MAAMd,KAACA,EAAIC,MAAEA,EAAKW,KAAEA,GAAQF,EAE5B,OAAOb,EAAQE,KAAOoB,EAAanB,GAAQC,EAAQW,EAC9C,GAAIF,EAAYK,aAAc,CACnC,MAAMf,KAACA,EAAIC,MAAEA,EAAKW,KAAEA,GAAQF,EAE5B,IAGIU,EAHAC,EAAWxB,EAAQG,KACnBsB,EAAezB,EAAQE,KAmB3B,OAfoB,IAAhBC,EAAKvD,OACP2E,EAAcC,GAGdA,EAAWA,EAAShB,UAAU,EAAGgB,EAASE,YAAY,MACtDH,EAAcD,EAAaE,EAAW,IAAMrB,IAO5CsB,GAHmB,KAAhBF,GAAyBnB,GAAYW,EAGxBQ,EAAcnB,EAAQW,EAFtB,MAhNtB,SAAShB,EAAW4B,GAClB,OAAOA,GAA6B,MAAtBA,EAAIA,EAAI/E,OAAO,GAAa,GAAK,KAIjD,SAAS0E,EAAcnB,GACrB,IAAIyB,EAAYzB,EAAK0B,MAAM,KAGN,KAAjBD,EAAU,KACZA,EAAYA,EAAU9E,MAAM,IAI9B,IAAIgF,EAAc,GAWlB,OAVAF,EAAUG,QAAQ,CAACC,EAAS/C,KAEV,MAAZ+C,IACc,OAAZA,EACFF,EAAYG,MACS,KAAZD,GACTF,EAAYI,KAAKF,MAIhB,IAAMF,EAAYK,KAAK,KAwGhC,SAASrC,EAAiB6B,GACxB,MAAMS,EAAgBT,EAAIzC,QAAQ,MAAQ,EACpCmD,GAAWV,EAAIW,SAAS,IAAKF,GAC7BG,GAAYZ,EAAIW,SAAS,IAAKF,GAC9BI,GAAWb,EAAIW,SAAS,IAAKF,GACnC,OAAQC,GAAUE,GAAWC,EChJ/B,MAAiBC,MCIjB,MAAiB,CAAEC,aAJGf,GAAQA,EAAIE,MAAM,IAAK,GAAG,GAIfc,YAHZhB,GAAQA,EAAIE,MAAM,IAAK,GAAG,IAAM,GAGPe,SAF5BpD,GAA2B,iBAAVA,IAAuBqD,MAAMC,QAAQtD,IAAoB,OAAVA,GCElF,mBAAQkD,WAAcE,GAAaG,EAG7BC,EAAY,CAACrB,EAAK5C,EAASkE,IAAS7E,OAAO8E,OAAO,CAAEvB,IAAAA,EAAK5C,QAAAA,EAASkE,KAAAA,IAClEE,EAAS,CAACC,EAAKC,IAAWjF,OAAO8E,OAAO,IAAKE,KAAQC,IAErDC,EAAMN,EAAU,GAAI,QAAIO,GACxBC,GAAUJ,GAAQA,EAAIH,KACtBzD,GAAS4D,GAAQK,GAAWL,GAAOM,GAAmBN,GAAK5D,MAAM4D,GAAOA,EAExEO,GAAMC,EAAMC,MAAOlC,EAAKmC,EAAYC,EAAU,MAClD,IAAIC,EACJ,MAAMZ,QAAYU,EACZG,EAAcC,EAAWd,EAAIzB,IAAKA,GAExC,GAAIe,EAAaU,EAAIzB,OAASe,EAAauB,GACzCD,EAASb,EAAOC,EAAK,CAAEzB,IAAKsC,SACvB,GAAIb,EAAIe,UAAYzB,EAAauB,KAAgBb,EAAIe,SAAU,CACpE,MAAMpF,EAAU,CAAEqF,eAAgBhB,EAAIrE,QAAQ,iBAC9CiF,EAAShB,EAAUiB,EAAalF,EAASqE,EAAIe,SAASF,QACjD,CACL,MAAMI,QAAiB5B,EAAMwB,EAAaF,GACpChF,EAAU,GAChB,IAAK,MAAOuF,EAAM9E,KAAU6E,EAAStF,QAAQwF,UAC3CxF,EAAQuF,GAAQ9E,EAElBwE,EAAShB,EAAUiB,EAAalF,QAAesF,EAASG,QAG1D,aAAad,GAAmBM,GAAQL,IAAIK,EAAQD,KAGhDU,GAAOb,EAAMC,MAAOvE,EAAK8D,EAAKW,EAAU,KAAON,SAAiBL,GACpEM,SAAyBN,GAAKqB,KAAKnF,QAAW8D,EAAKW,UAE5CX,GAAK9D,IAGRiF,GAAUV,MAAOT,EAAKW,EAAU,KAAON,SAAiBL,GAC5DsB,QAAQC,IAAIvG,OAAOM,KAAKc,SAAY4D,IACjCwB,IAAIf,MAAOvE,GAAQ,CAACA,QAAWmF,GAAKnF,QAAW8D,EAAKW,MAEvD3F,OAAOmG,cAAcnB,GAGjBwB,GAAMhB,EAAMC,MAAOpH,EAAI2G,EAAKW,EAAU,MAC1C,MAAMc,SAAcN,GAAQnB,EAAKW,IAC9Ba,IAAI,EAAEtF,EAAKwF,KAAUrI,EAAGqI,EAAMxF,IAEjC,OAAOoF,QAAQC,IAAIE,KAGfE,GAASnB,EAAMC,MAAOpH,EAAI2G,EAAKW,EAAU,KACtCiB,GAAOnB,MAAOoB,EAAKH,UACVrI,EAAGqI,GAASG,EAAI9H,OAAO,CAAC2H,IAASG,EAC9C,GAAI7B,EAAKW,IAGRmB,GAAOtB,EAAMC,MAAOpH,EAAI2G,EAAKW,EAAU,YAC7Ba,GAAInI,EAAI2G,EAAKW,IACxBmB,KAAMC,GAAMA,IAGXC,GAAQxB,EAAMC,MAAOpH,EAAI2G,EAAKW,EAAU,YAC9Ba,GAAInI,EAAI2G,EAAKW,IACxBqB,MAAOD,GAAMA,IAGZH,GAASpB,EAAMC,MAAOpH,EAAIwI,EAAK7B,EAAKW,EAAU,YACpCQ,GAAQnB,EAAKW,IACxBiB,OAAOnB,MAAOoB,GAAMI,EAAMP,KAAUrI,QAASwI,EAAKH,GAAOG,IAGxDK,GAAW1B,EAAM,CAAC2B,EAAKnC,IACpBmC,EAAIP,OAAOnB,MAAOoB,EAAKxI,IAAOA,QAASwI,GAAM7B,IAKhDoC,GAAe,GAEfC,GAAiB,CACrB9B,IAAKE,MAAOT,GAAQA,EACpB5D,MAAOgE,GACPiB,KAAMZ,MAAOvE,EAAK8D,IAAQ5D,GAAM4D,GAAK9D,IAGjCoE,GAAsBN,IAC1B,GAAIA,IAAQE,EACV,OAAOmC,GAGT,MAAMC,EAAcC,EAAkBC,MAAMxC,EAAIrE,QAAQ,iBAAiBb,KACzE,OAAOwH,KAAeF,GAAeA,GAAaE,GAAeD,IAG7DhC,GAAcjE,GAAUoD,EAASpD,IAAU,QAASA,EAE1D,OAAiB,CACfwD,UAAAA,EAAWG,OAAAA,EAAQ0C,eAtBE,CAACH,EAAaI,IAAYN,GAAaE,GAAeI,EAuB3ExC,IAAAA,EAAKK,IAAAA,GAAKH,OAAAA,GAAQhE,MAAAA,GAAO+E,QAAAA,GAASE,KAAAA,GAAMG,IAAAA,GAAKG,OAAAA,GAAQC,OAAAA,GAAQE,KAAAA,GAAME,MAAAA,GAAOE,SAAAA,ICrG5E,MAIM9F,GAAS4D,GAAQA,EAAI2C,KAG3B,OAAiB,KAPLlC,MAAOT,IACjB,MAAM2C,EAAOC,KAAKJ,MAAMK,GAAUzC,OAAOJ,IACzC,MAAS,SAAUA,EAAyCA,EAAlC6C,GAAU9C,OAAOC,EAAK,CAAE2C,KAAAA,WAK5BvG,QAFXqE,MAAOvE,EAAK8D,IAAQ5D,GAAM4D,GAAK9D,ICJ5C2G,GAAUJ,eAAe,mBAAoBK,ICD7C,MAgBMC,GAASvC,EAAM,CAACwC,EAASC,IAAYA,EAAU,IAAMC,GAAOF,IAE5DE,GAAUF,GAAYA,EAAQG,WAAWvI,QAAQ,KAAM,MAAMA,QAAQ,MAAO,MAC5EwI,GAAYJ,GAAYA,EAAQG,WAAWvI,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KAE9EyI,GAAe,CAACjH,EAAO4G,EAASC,EAAU,MAC9C,GAAc,OAAV7G,GAAmC,iBAAVA,EAC3B,MAAMe,mBAAmB8F,uCACpB,KAAMD,KAAW5G,GACtB,MAAMe,mBAAmB8F,2BAAiCD,MAG5D,OAAO5G,EAAM4G,IAGf,OAAiB,KA/BL,OAEA,CAACC,EAAS7G,KACpB,GAAI6G,EAAQzJ,OAAS,GAAoB,MAAfyJ,EAAQ,GAChC,MAAM9F,MAAM,wBAGd,MAAMmG,EAAML,EAAQxE,MAAM,KAAK/E,MAAM,GAAG8H,IAAI4B,IAEtC/J,EAAM+C,GAAUkH,EAAI1B,OAAO,EAAExF,EAAO6G,GAAUD,IAC3C,CAACK,GAAajH,EAAO4G,EAASC,GAAUF,GAAOC,EAASC,IAC9D,CAAC7G,EAAO,KAAK,GAEhB,YAAiB+D,IAAV/D,EAAsB/C,EAAKA,EAAG+C,IAkBV2G,OAAAA,IChC7B,mBAAQzD,eAAcC,YAAaC,IAAaG,EAS1C6C,GAASxC,IACb,MAAMe,EAAW,GAYjB,MAAO,CAAEwC,KAXIX,KAAKJ,MAAMK,GAAUzC,OAAOJ,GAAM,CAAC9D,EAAKE,KACnD,GAAIoH,GAAWpH,GAAQ,CACrB,MAAMqH,EAAKnE,GAAalD,EAAiB,WAGzC,cAFOA,EAAiB,UACxB2E,EAAS0C,GAAMb,KAAKc,UAAUtH,GACvB,CAAEuH,MAASF,GAElB,OAAOrH,IAII2E,SAAAA,IAGX3E,GAAS4D,GAAQ4D,GAAYrD,IAAI0C,GAAQjD,GAAMA,EAAIuD,MAQnDN,GAAWjD,GAAQ6D,mBAAmBtE,GAAYS,EAAIzB,MACtDuF,GAAU1H,GAAUoD,GAASpD,IAAU,UAAWA,EAClDoH,GAAcpH,GAAUoD,GAASpD,IAAU,cAAeA,EAEhE,OAAiB,KAlCLqE,MAAOT,EAAKW,KACtB,MAAMoD,EAAY,SAAU/D,EAA2CA,EAApC6C,GAAU9C,OAAOC,EAAKwC,GAAMxC,IACzDgE,EAAW5H,GAAM2H,GACvB,OAAOD,GAAOE,SAAkBnB,GAAUtC,IAAIyD,EAAgB,MAAGD,EAASpD,GAAWoD,SA+B/D3H,QAVX,CAACF,EAAK8D,EAAKW,EAAU,MAChC,MAAM2C,EAAMM,GAAYb,OAAO7G,EAAK+G,GAAQjD,IACtCzB,EAAM,IAAM0F,UAAUX,GAAK1I,QAAQ,KAAM,OAC/C,OAAOiI,GAAUtC,IAAIhC,EAAKyB,EAAKW,KC5BjCkC,GAAUJ,eAAe,6BAA8BK,ICCvD,OAAiBD,GCDjB,MAcMqB,GAAU,CAACC,EAAc5F,KAC7B,MAAM+E,EAAMM,GAAYb,OAAOoB,EAFjB,CAAC5F,GAAQsF,mBADL,CAACtF,GAAQA,EAAIE,MAAM,IAAK,GAAG,IAAM,GACTc,CAAYhB,IAET0E,CAAQ1E,IAC/C6F,EAAW,IAAMH,UAAUX,GAAK1I,QAAQ,KAAM,OACpD,OAAOkG,EAAWvC,EAAK6F,IAGnBC,GAAWC,GAAUA,EAAMxF,KAAK,IAEhCyF,GAAY,CAACD,KAAUE,KAC3BF,EAAMA,EAAM9K,OAAS,GAAGsF,QAAQ0F,IAG5BC,GAAQ,CAACC,EAAGC,KAChB,MAAMC,EAAQ,GACd,IAAK,IAAIpJ,EAAI,EAAGA,EAAIkJ,EAAGlJ,IACrBoJ,EAAM9F,KAAK6F,GAGb,OAAOC,GAGIC,GAAgB,CAACtG,EAAKoE,EAAM2B,EAAQ,CAAC,IAAKQ,EAAQ,KAC7D,MAAMC,EApCW,CAAC3I,IAClB,GAAc,OAAVA,EACF,MAAO,OAET,GAAIqD,MAAMC,QAAQtD,GAChB,MAAO,QAGT,MAAMtB,SAAcsB,EACpB,MAAgB,WAATtB,GAAqB,UAAWsB,EAAQ,OAAStB,GA2BvCkK,CAAWrC,GAE5B,GAAiB,WAAboC,EAAuB,CACzBR,GAAUD,EAAO,CAAC,WAAY,MAC9BD,GAAQC,GACR,MAAMnD,EAAUnG,OAAOmG,QAAQwB,GAC/B,IAAK,IAAIsC,EAAM,EAAGA,EAAM9D,EAAQ3H,OAAQyL,IAAO,CAC7C,MAAOd,EAAce,GAAiB/D,EAAQ8D,GAExCE,EAAcjB,GAAQC,EAAc5F,GAC1CgG,GAAUD,KAAUG,GAAMK,EAAQ,EAAG,CAAC,WAAY,CAAC,WAAYX,EAAcgB,IAC7EN,GAAcM,EAAaD,EAAeZ,EAAOQ,EAAQ,GACzDG,EAAM9D,EAAQ3H,OAAS,GAAK+K,GAAUD,EAAO,CAAC,UAC9CD,GAAQC,GAEVC,GAAUD,KAAUG,GAAMK,EAAO,CAAC,WAAY,CAAC,WAAY,WACtD,GAAiB,UAAbC,EAAsB,CAC/BR,GAAUD,EAAO,CAAC,WAAY,MAC9BD,GAAQC,GACR,IAAK,IAAIW,EAAM,EAAGA,EAAMtC,EAAKnJ,OAAQyL,IAAO,CAC1C,MAAME,EAAcjB,GAAQe,EAAK1G,GACjCgG,GAAUD,KAAUG,GAAMK,EAAQ,EAAG,CAAC,WAAY,CAAC,cAAeG,EAAKE,IACvEN,GAAcM,EAAaxC,EAAKsC,GAAMX,EAAOQ,EAAQ,GACrDG,EAAMtC,EAAKnJ,OAAS,GAAK+K,GAAUD,EAAO,CAAC,UAC3CD,GAAQC,GAEVC,GAAUD,KAAUG,GAAMK,EAAO,CAAC,WAAY,CAAC,WAAY,UACrC,WAAbC,EACTR,GAAUD,EAAO,CAAC,SAAU3B,IACN,WAAboC,EACTR,GAAUD,EAAO,CAAC,SAAU3B,IACN,YAAboC,EACTR,GAAUD,EAAO,CAAC,OAAQ3B,EAAO,OAAQ,UACnB,SAAboC,EACTR,GAAUD,EAAO,CAAC,OAAQ,SACJ,SAAbS,GACTR,GAAUD,EAAO,CAAC,OAAQxD,EAAWvC,EAAKoE,EAAY,SAGxD,OAAO2B,kuBChCJc,MAAMC,oFAAND,MAAMC,wEA1BAf,mBAAL9K,iGAAAA,iDAAAA,oDAAAA,wEAAK8K,sBAAL9K,+HAAAA,WAAAA,mDAAAA,oEAAAA,yEAoBa,SAAS8L,SAAOC,+KAAhB,SAASD,SAAOC,iXAJZC,MAAM,uFAANA,MAAM,sEAFGA,MAAM,+MAANA,MAAM,+DAFJA,MAAM,iNAANA,MAAM,mEAFAA,MAAM,2QAANA,MAAM,8YAJkBA,MAAM,4PAAlBA,MAAM,kJAAMA,MAAM,kCAAlBA,MAAM,kFAFtBA,MAAM,mNAANA,MAAM,iEAIoBA,MAAM,gJAAtCA,MAAM,+FAA0BA,MAAM,kCAAtCA,MAAM,sHALR,eAAbA,MAAM,KAEY,eAAbA,MAAM,KAEO,kBAAbA,MAAM,KAEO,aAAbA,MAAM,KAEO,aAAbA,MAAM,KAEO,WAAbA,MAAM,KAEO,WAAbA,MAAM,KAEO,YAAbA,MAAM,KAEO,aAAbA,MAAM,4XAjBXC,kBAALjM,4GAAAA,4FAAAA,sIAAAA,yEAAKiM,qBAALjM,oHAAAA,WAAAA,mDAAAA,oEAAAA,sUALA8K,+JADaoB,iJACbpB,sFADaoB,gMAXd,WAAI1F,EAAGuF,OACHA,EAAMG,MACNA,yKAERpB,EAAS7D,iBACV,MAAMkF,QAAU3F,EACV5D,EAAQyG,GAAUzG,MAAMuJ,GAC9B,OAAOd,GAAcc,EAAEpH,IAAKnC,+MCgDd4D,qBAAiB0F,qbALVA,8DAETnH,uDAXcqH,4BAYXC,iHADHtH,8BAGEyB,uBAAiB0F,gHAnDjC,MAAMA,GAAQ,oCAHd7C,GAAUJ,eAAe,8BAA+BqD,IAExD,IAAIvH,EAAM,GAGVwH,EAAQ,KACFC,OAAOC,SAASvI,KAAKhE,MAAMsM,OAAOC,SAASC,OAAO1M,UAAYwM,OAAOC,SAASE,UAChFH,OAAOC,SAASrL,QAAQ,MAG1BgL,MAGF,MAAMA,EAAe,aACnBrH,EAAM6H,UAAUJ,OAAOC,SAAStI,KAAKP,UAAU,4EAU9C4C,EAAOS,iBACR,GAAY,KAARlC,EACF,OAAOsE,GAAU3C,IAGnB,MAAMmG,EAAgBJ,SAASvI,KAAKvB,MAAM,YAAY,GAChDmK,EAAS/H,EAAIE,MAAM,IAAK,GAAG,GACjCuH,OAAOC,SAASrL,WAAW0L,KAAUD,KAErC,MAAME,QAAgB1D,GAAUtC,IAAIhC,EAAKyB,GAAO6C,GAAU3C,KAG1D,OAFA8F,OAAOC,SAASrL,QAAQoL,OAAOC,SAASC,OAAS,KAAOjC,UAAUsC,EAAQhI,MAEnEgI,iCAnBGC,IACY,KAAlBA,EAAMC,UACRT,OAAOC,SAAStI,KAAOsG,UAAUuC,EAAME,OAAOtK,eAC9CmC,EAAMiI,EAAME,OAAOtK"}